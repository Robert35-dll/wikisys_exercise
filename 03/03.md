Im diesem Workshop laden wir alles Wissen der Welt in ChatGPT und erstellen eine Ontologie f√ºr den _Herrn der Ringe_. Alternativ d√ºrfen Sie aber auch ein Schaf √ºber den Fluss bringen...


## Option A: Wissen formalisieren

### üöÄ Challenge #A1: Eigene Knowledge Base

Wir wollen nun selbst damit experimentieren, Wissen zug√§nglich zu machen.

![](./images/KAOS.png)

L√∂sen Sie die folgende Aufgabe gemeinsam mit einem Kommilitonen:

**Aufgabe:** W√§hlen Sie ein komplexes, aber allgemein bekanntes Thema wie ein gemeinsames Hobby, ein wissenschaftlichese Fachgebiet oder ein bekanntes "Universum" aus Film/ Literatur. Zeichnen Sie jeweils alleine auf einem gro√üen Blatt Papier die wesentlichen _Entit√§ten_ und deren _Beziehungen_. Vergleichen Sie Ihre Ergebnisse!


**Aufgabe f√ºr Fortgeschrittene:** Wenn Sie hier weiter experimentieren wollen, lassen Sie sich von ChatGPT ein Tutorial schreiben, wie Sie Ihre Knowledge Base in einen Neo4J Graphen eingeben und mit Hilfe von ChatGPT durchsuchbar machen k√∂nnen. So k√∂nnen Sie mit Python z√ºgig einen Expertenbot f√ºr Ihr Hobby bauen. 
{: .notice} 


### üöÄ Challenge #A2: OpenAI GPT  <3 Google Knowledge Graph

**Aufgabe:** Studieren Sie die Google Knowledge Graph Dokumentation (oder irgendeine andere Quelle), um herauszufinden, wie Google sein Wissen organisiert und wie Sie Fragen an die API stellen k√∂nnen. 

**Aufgabe:** Studieren Sie die OpenAI Dokumentation (oder irgendeine andere Quelle), um herauszufinden, wie Sie Fragen an die ChatGPT API senden k√∂nnen.


**Aufgabe:** Kombinieren Sie die beiden L√∂sungen, um ChatGPT mit umfangreichem Wissen zu f√ºttern! Laut einer Anfrage an ChatGPT sieht die L√∂sung [ungef√§hr so](gkg.ipynb) aus - allerdings l√§uft der Code so noch nicht. Viel Erfolg!


## Option B: L√∂sungen finden

### üöÄ Challenge #B1: Von W√∂lfen, Schafen und Kohlk√∂pfen

![](https://miro.medium.com/v2/resize:fit:720/format:webp/1*FHeFxQNi_kZW208PTAonFw.jpeg)

> Es war einmal, in einem charmanten Dorf, das malerisch an einem gewundenen Fluss lag, ein kluger Bauer namens Alex. Alex stand vor einer ungew√∂hnlichen Herausforderung: Er musste einen Wolf, eine Ziege und einen Kohlkopf √ºber den Fluss zu seinem anderen Hof transportieren. Doch er hatte nur ein kleines Boot, das ihn und ein weiteres Ding oder Lebewesen zur selben Zeit tragen konnte. Sein Problem: Der Wolf w√ºrde die Ziege angreifen, wenn sie allein gelassen w√ºrden, und die Ziege w√ºrde den Kohl fressen, wenn sie unbeaufsichtigt bliebe. Daher musste Alex jede √úberfahrt sorgf√§ltig planen, um sicherzustellen, dass jedes Ding wohlbehalten auf die andere Seite des Flusses gelangte.

**Aufgabe:** Formulieren Sie einen Entwurf an der Tafel, der das hier beschriebene M√§rchen als Suchproblem.


**Tipp:** Sie k√∂nnen den **Zustand** der M√§rchenwelt formalisieren, indem Sie notieren, wer auf welcher Seite des Flusses ist, z.B.
```python
state = (alex, wolf, goat, cabbage)
```

Der Startzustand w√§re dann "alle sind auf der linken Seite":
```python
start = (0, 0, 0, 0)
```

Ebenso k√∂nnen Sie eine Bewegung (move) √ºber den Fluss als Tupel kodieren. Alex bewegt sich immer, also m√ºssen wir ihn nicht aufschreiben. Aber wen nimmt er mit sich?
```python
move_with_wolf = (1, 0, 0)  # Alex moves wolf
move_with_goat = (0, 1, 0)  # Alex moves goat
move_with_cabb = (0, 1, 0)  # Alex moves cabbage
```
Achtung, Alex kann auch einfach so herumfahren:
```python
move_with_none = (0, 0, 0)  # Alex moves nothing
```


Wenn dann Alex und der Wolf gemeinsam den Fluss √ºberquert haben, w√§re der Zustand
```python
start = (0, 0, 0, 0)
move_with_wolf = (1, 0, 0)  # Alex moves wolf
```
Das Ergebnis: Alex und Wolf sind auf der anderen Seite:
```python
result = (1, 1, 0, 0)
```

**Aufgabe:** Implementieren Sie das Suchproblem in Python und durchsuchen Sie den resultierenden Baum mit einer geeigneten Such-Strategie, um eine Strategie f√ºr Alex zu finden. Der folgende unvollst√§ndige Python-Code nimmt Ihnen etwas Arbeit ab:



<!--- L√∂sungsbeschreibung hier: https://medium.com/@davidlfliang/intro-graph-theory-in-python-river-crossing-problem-975aef200c81
--> 


```python
# Final Demo Version
from collections import deque

# State representation: (alex, wolf, goat, cabbage)
# alex, wolf, goat, cabbage are either 0 (left) or 1 (right)
initial_state = (0, 0, 0, 0)  # Alex, wolf, goat, cabbage all on the left
goal_state = (1, 1, 1, 1)     # Alex, wolf, goat, cabbage all on the right

def is_valid_state(state):
    alex, wolf, goat, cabbage = state

    # Ensure the goat is not left alone with the wolf etc.
    if (   ...  ):
        return False
    return True


# generate neighbors in search problem for a specific state
def get_neighbors(state):

    alex, wolf, goat, cabbage = state
    neighbors = []

    # Generate all possible moves (Alex carries one item or none)
    possible_moves = [(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]

    for move in possible_moves:

        wolf_move, goat_move, cabbage_move = move

        # Ensure that the move is valid
        if alex == 0:  # Alex is on the left side
            # compute new state based on move
            new_alex_pos = 1
            new_wolf = ...
            new_goat = ...
            new_cabbage = ...
        else:  # Alex is on the right side
            new_alex_pos = 0
            new_wolf = ...
            new_goat = ...
            new_cabbage = ...


        # Ensure the new state is within valid bounds (0 or 1)
        if not (0 <= new_wolf <= 1 and 0 <= new_goat <= 1 and 0 <= new_cabbage <= 1):
            continue

        new_state = (new_alex_pos, new_wolf, new_goat, new_cabbage)
        if is_valid_state(new_state):
            neighbors.append(new_state)

    return neighbors

def bfs():
    queue = deque([(initial_state, [])])
    visited = set()
    visited.add(initial_state)

    while queue:
        state, path = queue.popleft()

        if ... Check: Ziel erreicht?

        # else
        for neighbor in get_neighbors(state):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [state]))

    return None

if __name__ == "__main__":
  solution = bfs()
  if solution:
      for step in solution:
          # print(step)  
          ... (Printe die L√∂sung in verst√§ndlichen Worten)
  else:
      ## keine L√∂sung gefunden
      ...

```
